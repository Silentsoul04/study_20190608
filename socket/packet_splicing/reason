#产生粘包的原因
两种原因:
一:客户端(recv)不能一次性读取缓冲区中的数据.
服务端发送的数据大于客户端能够接受的数据量,
客户端下次接收的时候先去接收上次遗留在缓冲区中的数据.造成粘包 
(例如接收端缓冲区过小就会产生粘包，或者一次只读取少量数据)
act_res = s.recv(128)   
由于客户端发的命令获取的结果大小已经超过128，那么下次在输入命令，会继续取上次残留到缓存区的数据
二：
客户端(send)向服务端发送数据的时候,  发送多条少量数据. 
由于缓冲区的没有存满,缓冲区会把这些数据聚集在一起发送给服务端.造成粘包
两次发送信息时间间隔太短，数据小，造成服务端一次收取

### 步骤解释
调用struct模块
报头做成字典，字典里包含将要发送的真实数据的详细信息，然后json序列化，
然后用struck将序列化后的数据长度打包成4个字节

#发送时：
    1.先发报头长度
    2.再编码报头内容然后发送
    3.最后发真实内容

#接收时：
    1.先手报头长度，用struct取出来
    2.根据取出的长度收取报头内容，然后解码，反序列化
    3.从反序列化的结果中取出待取数据的详细信息，然后去取真实的数据内容

